// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ntx/auth/token.proto

/*
	Package auth is a generated protocol buffer package.

	It is generated from these files:
		ntx/auth/token.proto
		ntx/auth/user.proto

	It has these top-level messages:
		OAuthClientCredentials
		OAuthResourceOwnerCredentials
		OAuthToken
		GetAccessToken
		AccessToken
		NtxTokenRequest
		CustomNtxTokenRequest
		NtxStoreToken
		NtxTokenResponse
		AuthProviderConfig
		NtxToken
		Group
		User
		GroupList
		UserList
		UserStoreSnapshot
*/
package auth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import ntx_scheduler "gitlab.com/nanotrix/nanogrid/pkg/ntx/scheduler"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Client Credentials Grant
type OAuthClientCredentials struct {
	Audience     string `protobuf:"bytes,1,opt,name=audience,proto3" json:"audience,omitempty"`
	GrantType    string `protobuf:"bytes,2,opt,name=grant_type,json=grantType,proto3" json:"grant_type,omitempty"`
	ClientId     string `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	ClientSecret string `protobuf:"bytes,4,opt,name=client_secret,json=clientSecret,proto3" json:"client_secret,omitempty"`
}

func (m *OAuthClientCredentials) Reset()                    { *m = OAuthClientCredentials{} }
func (m *OAuthClientCredentials) String() string            { return proto.CompactTextString(m) }
func (*OAuthClientCredentials) ProtoMessage()               {}
func (*OAuthClientCredentials) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{0} }

func (m *OAuthClientCredentials) GetAudience() string {
	if m != nil {
		return m.Audience
	}
	return ""
}

func (m *OAuthClientCredentials) GetGrantType() string {
	if m != nil {
		return m.GrantType
	}
	return ""
}

func (m *OAuthClientCredentials) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *OAuthClientCredentials) GetClientSecret() string {
	if m != nil {
		return m.ClientSecret
	}
	return ""
}

// Resource Owner Password Grant
type OAuthResourceOwnerCredentials struct {
	Audience  string `protobuf:"bytes,1,opt,name=audience,proto3" json:"audience,omitempty"`
	GrantType string `protobuf:"bytes,2,opt,name=grant_type,json=grantType,proto3" json:"grant_type,omitempty"`
	ClientId  string `protobuf:"bytes,3,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	Scope     string `protobuf:"bytes,5,opt,name=scope,proto3" json:"scope,omitempty"`
	Username  string `protobuf:"bytes,6,opt,name=username,proto3" json:"username,omitempty"`
	Password  string `protobuf:"bytes,7,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *OAuthResourceOwnerCredentials) Reset()         { *m = OAuthResourceOwnerCredentials{} }
func (m *OAuthResourceOwnerCredentials) String() string { return proto.CompactTextString(m) }
func (*OAuthResourceOwnerCredentials) ProtoMessage()    {}
func (*OAuthResourceOwnerCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptorToken, []int{1}
}

func (m *OAuthResourceOwnerCredentials) GetAudience() string {
	if m != nil {
		return m.Audience
	}
	return ""
}

func (m *OAuthResourceOwnerCredentials) GetGrantType() string {
	if m != nil {
		return m.GrantType
	}
	return ""
}

func (m *OAuthResourceOwnerCredentials) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *OAuthResourceOwnerCredentials) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *OAuthResourceOwnerCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *OAuthResourceOwnerCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// oauth2 token
type OAuthToken struct {
	AccessToken string `protobuf:"bytes,1,opt,name=access_token,json=accessToken,proto3" json:"access_token,omitempty"`
	TokenType   string `protobuf:"bytes,2,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	ExpiresIn   uint64 `protobuf:"varint,3,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
}

func (m *OAuthToken) Reset()                    { *m = OAuthToken{} }
func (m *OAuthToken) String() string            { return proto.CompactTextString(m) }
func (*OAuthToken) ProtoMessage()               {}
func (*OAuthToken) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{2} }

func (m *OAuthToken) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *OAuthToken) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

func (m *OAuthToken) GetExpiresIn() uint64 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

// Login API
type GetAccessToken struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *GetAccessToken) Reset()                    { *m = GetAccessToken{} }
func (m *GetAccessToken) String() string            { return proto.CompactTextString(m) }
func (*GetAccessToken) ProtoMessage()               {}
func (*GetAccessToken) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{3} }

func (m *GetAccessToken) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GetAccessToken) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type AccessToken struct {
	AccessToken string `protobuf:"bytes,1,opt,name=accessToken,proto3" json:"accessToken,omitempty"`
	ExpiresAt   uint64 `protobuf:"varint,2,opt,name=expiresAt,proto3" json:"expiresAt,omitempty"`
}

func (m *AccessToken) Reset()                    { *m = AccessToken{} }
func (m *AccessToken) String() string            { return proto.CompactTextString(m) }
func (*AccessToken) ProtoMessage()               {}
func (*AccessToken) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{4} }

func (m *AccessToken) GetAccessToken() string {
	if m != nil {
		return m.AccessToken
	}
	return ""
}

func (m *AccessToken) GetExpiresAt() uint64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// Store API
type NtxTokenRequest struct {
	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *NtxTokenRequest) Reset()                    { *m = NtxTokenRequest{} }
func (m *NtxTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*NtxTokenRequest) ProtoMessage()               {}
func (*NtxTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{5} }

func (m *NtxTokenRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NtxTokenRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

type CustomNtxTokenRequest struct {
	Label string                           `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Task  *ntx_scheduler.TaskConfiguration `protobuf:"bytes,2,opt,name=task" json:"task,omitempty"`
}

func (m *CustomNtxTokenRequest) Reset()                    { *m = CustomNtxTokenRequest{} }
func (m *CustomNtxTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*CustomNtxTokenRequest) ProtoMessage()               {}
func (*CustomNtxTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{6} }

func (m *CustomNtxTokenRequest) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *CustomNtxTokenRequest) GetTask() *ntx_scheduler.TaskConfiguration {
	if m != nil {
		return m.Task
	}
	return nil
}

type NtxStoreToken struct {
	NtxToken  string `protobuf:"bytes,1,opt,name=ntxToken,proto3" json:"ntxToken,omitempty"`
	ExpiresAt uint64 `protobuf:"varint,2,opt,name=expiresAt,proto3" json:"expiresAt,omitempty"`
}

func (m *NtxStoreToken) Reset()                    { *m = NtxStoreToken{} }
func (m *NtxStoreToken) String() string            { return proto.CompactTextString(m) }
func (*NtxStoreToken) ProtoMessage()               {}
func (*NtxStoreToken) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{7} }

func (m *NtxStoreToken) GetNtxToken() string {
	if m != nil {
		return m.NtxToken
	}
	return ""
}

func (m *NtxStoreToken) GetExpiresAt() uint64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// @deprecated since 1.5
type NtxTokenResponse struct {
	// Types that are valid to be assigned to Response:
	//	*NtxTokenResponse_Token_
	//	*NtxTokenResponse_Error_
	Response isNtxTokenResponse_Response `protobuf_oneof:"response"`
}

func (m *NtxTokenResponse) Reset()                    { *m = NtxTokenResponse{} }
func (m *NtxTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*NtxTokenResponse) ProtoMessage()               {}
func (*NtxTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{8} }

type isNtxTokenResponse_Response interface {
	isNtxTokenResponse_Response()
	MarshalTo([]byte) (int, error)
	Size() int
}

type NtxTokenResponse_Token_ struct {
	Token *NtxTokenResponse_Token `protobuf:"bytes,1,opt,name=token,oneof"`
}
type NtxTokenResponse_Error_ struct {
	Error *NtxTokenResponse_Error `protobuf:"bytes,2,opt,name=error,oneof"`
}

func (*NtxTokenResponse_Token_) isNtxTokenResponse_Response() {}
func (*NtxTokenResponse_Error_) isNtxTokenResponse_Response() {}

func (m *NtxTokenResponse) GetResponse() isNtxTokenResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *NtxTokenResponse) GetToken() *NtxTokenResponse_Token {
	if x, ok := m.GetResponse().(*NtxTokenResponse_Token_); ok {
		return x.Token
	}
	return nil
}

func (m *NtxTokenResponse) GetError() *NtxTokenResponse_Error {
	if x, ok := m.GetResponse().(*NtxTokenResponse_Error_); ok {
		return x.Error
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NtxTokenResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NtxTokenResponse_OneofMarshaler, _NtxTokenResponse_OneofUnmarshaler, _NtxTokenResponse_OneofSizer, []interface{}{
		(*NtxTokenResponse_Token_)(nil),
		(*NtxTokenResponse_Error_)(nil),
	}
}

func _NtxTokenResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NtxTokenResponse)
	// response
	switch x := m.Response.(type) {
	case *NtxTokenResponse_Token_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Token); err != nil {
			return err
		}
	case *NtxTokenResponse_Error_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NtxTokenResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _NtxTokenResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NtxTokenResponse)
	switch tag {
	case 1: // response.token
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NtxTokenResponse_Token)
		err := b.DecodeMessage(msg)
		m.Response = &NtxTokenResponse_Token_{msg}
		return true, err
	case 2: // response.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NtxTokenResponse_Error)
		err := b.DecodeMessage(msg)
		m.Response = &NtxTokenResponse_Error_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NtxTokenResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NtxTokenResponse)
	// response
	switch x := m.Response.(type) {
	case *NtxTokenResponse_Token_:
		s := proto.Size(x.Token)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *NtxTokenResponse_Error_:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NtxTokenResponse_Token struct {
	// ntx token string
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// ntx token type
	//      ntx-token
	//      local-store-content
	//      local-store-license
	TokenType string `protobuf:"bytes,2,opt,name=tokenType,proto3" json:"tokenType,omitempty"`
}

func (m *NtxTokenResponse_Token) Reset()                    { *m = NtxTokenResponse_Token{} }
func (m *NtxTokenResponse_Token) String() string            { return proto.CompactTextString(m) }
func (*NtxTokenResponse_Token) ProtoMessage()               {}
func (*NtxTokenResponse_Token) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{8, 0} }

func (m *NtxTokenResponse_Token) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *NtxTokenResponse_Token) GetTokenType() string {
	if m != nil {
		return m.TokenType
	}
	return ""
}

type NtxTokenResponse_Error struct {
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *NtxTokenResponse_Error) Reset()                    { *m = NtxTokenResponse_Error{} }
func (m *NtxTokenResponse_Error) String() string            { return proto.CompactTextString(m) }
func (*NtxTokenResponse_Error) ProtoMessage()               {}
func (*NtxTokenResponse_Error) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{8, 1} }

func (m *NtxTokenResponse_Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type AuthProviderConfig struct {
	Issuer string `protobuf:"bytes,1,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// one of
	Rs256 *AuthProviderConfig_RS256 `protobuf:"bytes,15,opt,name=rs256" json:"rs256,omitempty"`
	Hs256 *AuthProviderConfig_HS256 `protobuf:"bytes,16,opt,name=hs256" json:"hs256,omitempty"`
}

func (m *AuthProviderConfig) Reset()                    { *m = AuthProviderConfig{} }
func (m *AuthProviderConfig) String() string            { return proto.CompactTextString(m) }
func (*AuthProviderConfig) ProtoMessage()               {}
func (*AuthProviderConfig) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{9} }

func (m *AuthProviderConfig) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *AuthProviderConfig) GetRs256() *AuthProviderConfig_RS256 {
	if m != nil {
		return m.Rs256
	}
	return nil
}

func (m *AuthProviderConfig) GetHs256() *AuthProviderConfig_HS256 {
	if m != nil {
		return m.Hs256
	}
	return nil
}

type AuthProviderConfig_RS256 struct {
	Input string `protobuf:"bytes,1,opt,name=input,proto3" json:"input,omitempty"`
}

func (m *AuthProviderConfig_RS256) Reset()                    { *m = AuthProviderConfig_RS256{} }
func (m *AuthProviderConfig_RS256) String() string            { return proto.CompactTextString(m) }
func (*AuthProviderConfig_RS256) ProtoMessage()               {}
func (*AuthProviderConfig_RS256) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{9, 0} }

func (m *AuthProviderConfig_RS256) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

type AuthProviderConfig_HS256 struct {
	Secret string `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *AuthProviderConfig_HS256) Reset()                    { *m = AuthProviderConfig_HS256{} }
func (m *AuthProviderConfig_HS256) String() string            { return proto.CompactTextString(m) }
func (*AuthProviderConfig_HS256) ProtoMessage()               {}
func (*AuthProviderConfig_HS256) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{9, 1} }

func (m *AuthProviderConfig_HS256) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

type NtxToken struct {
	// Issuer
	Iss string `protobuf:"bytes,1,opt,name=iss,proto3" json:"iss,omitempty"`
	// IssuedAt
	Iat int64 `protobuf:"varint,2,opt,name=iat,proto3" json:"iat,omitempty"`
	// NotBefore
	Nbf int64 `protobuf:"varint,3,opt,name=nbf,proto3" json:"nbf,omitempty"`
	// Expires
	Exp int64 `protobuf:"varint,4,opt,name=exp,proto3" json:"exp,omitempty"`
	// Audience
	Aud []string `protobuf:"bytes,5,rep,name=aud" json:"aud,omitempty"`
	// Subject
	Sub string `protobuf:"bytes,6,opt,name=sub,proto3" json:"sub,omitempty"`
	// Nonce
	Jti         string         `protobuf:"bytes,7,opt,name=jti,proto3" json:"jti,omitempty"`
	Permissions []string       `protobuf:"bytes,8,rep,name=permissions" json:"permissions,omitempty"`
	Email       string         `protobuf:"bytes,9,opt,name=email,proto3" json:"email,omitempty"`
	Task        *NtxToken_Task `protobuf:"bytes,10,opt,name=task" json:"task,omitempty"`
}

func (m *NtxToken) Reset()                    { *m = NtxToken{} }
func (m *NtxToken) String() string            { return proto.CompactTextString(m) }
func (*NtxToken) ProtoMessage()               {}
func (*NtxToken) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{10} }

func (m *NtxToken) GetIss() string {
	if m != nil {
		return m.Iss
	}
	return ""
}

func (m *NtxToken) GetIat() int64 {
	if m != nil {
		return m.Iat
	}
	return 0
}

func (m *NtxToken) GetNbf() int64 {
	if m != nil {
		return m.Nbf
	}
	return 0
}

func (m *NtxToken) GetExp() int64 {
	if m != nil {
		return m.Exp
	}
	return 0
}

func (m *NtxToken) GetAud() []string {
	if m != nil {
		return m.Aud
	}
	return nil
}

func (m *NtxToken) GetSub() string {
	if m != nil {
		return m.Sub
	}
	return ""
}

func (m *NtxToken) GetJti() string {
	if m != nil {
		return m.Jti
	}
	return ""
}

func (m *NtxToken) GetPermissions() []string {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *NtxToken) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *NtxToken) GetTask() *NtxToken_Task {
	if m != nil {
		return m.Task
	}
	return nil
}

type NtxToken_Task struct {
	Id    string                           `protobuf:"bytes,15,opt,name=id,proto3" json:"id,omitempty"`
	Cfg   *ntx_scheduler.TaskConfiguration `protobuf:"bytes,2,opt,name=cfg" json:"cfg,omitempty"`
	Label string                           `protobuf:"bytes,3,opt,name=label,proto3" json:"label,omitempty"`
	Role  string                           `protobuf:"bytes,4,opt,name=role,proto3" json:"role,omitempty"`
	// is custom task
	Custom bool `protobuf:"varint,6,opt,name=custom,proto3" json:"custom,omitempty"`
}

func (m *NtxToken_Task) Reset()                    { *m = NtxToken_Task{} }
func (m *NtxToken_Task) String() string            { return proto.CompactTextString(m) }
func (*NtxToken_Task) ProtoMessage()               {}
func (*NtxToken_Task) Descriptor() ([]byte, []int) { return fileDescriptorToken, []int{10, 0} }

func (m *NtxToken_Task) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NtxToken_Task) GetCfg() *ntx_scheduler.TaskConfiguration {
	if m != nil {
		return m.Cfg
	}
	return nil
}

func (m *NtxToken_Task) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *NtxToken_Task) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *NtxToken_Task) GetCustom() bool {
	if m != nil {
		return m.Custom
	}
	return false
}

func init() {
	proto.RegisterType((*OAuthClientCredentials)(nil), "ntx.auth.OAuthClientCredentials")
	proto.RegisterType((*OAuthResourceOwnerCredentials)(nil), "ntx.auth.OAuthResourceOwnerCredentials")
	proto.RegisterType((*OAuthToken)(nil), "ntx.auth.OAuthToken")
	proto.RegisterType((*GetAccessToken)(nil), "ntx.auth.GetAccessToken")
	proto.RegisterType((*AccessToken)(nil), "ntx.auth.AccessToken")
	proto.RegisterType((*NtxTokenRequest)(nil), "ntx.auth.NtxTokenRequest")
	proto.RegisterType((*CustomNtxTokenRequest)(nil), "ntx.auth.CustomNtxTokenRequest")
	proto.RegisterType((*NtxStoreToken)(nil), "ntx.auth.NtxStoreToken")
	proto.RegisterType((*NtxTokenResponse)(nil), "ntx.auth.NtxTokenResponse")
	proto.RegisterType((*NtxTokenResponse_Token)(nil), "ntx.auth.NtxTokenResponse.Token")
	proto.RegisterType((*NtxTokenResponse_Error)(nil), "ntx.auth.NtxTokenResponse.Error")
	proto.RegisterType((*AuthProviderConfig)(nil), "ntx.auth.AuthProviderConfig")
	proto.RegisterType((*AuthProviderConfig_RS256)(nil), "ntx.auth.AuthProviderConfig.RS256")
	proto.RegisterType((*AuthProviderConfig_HS256)(nil), "ntx.auth.AuthProviderConfig.HS256")
	proto.RegisterType((*NtxToken)(nil), "ntx.auth.NtxToken")
	proto.RegisterType((*NtxToken_Task)(nil), "ntx.auth.NtxToken.Task")
}
func (m *OAuthClientCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthClientCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Audience) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Audience)))
		i += copy(dAtA[i:], m.Audience)
	}
	if len(m.GrantType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.GrantType)))
		i += copy(dAtA[i:], m.GrantType)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.ClientSecret) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.ClientSecret)))
		i += copy(dAtA[i:], m.ClientSecret)
	}
	return i, nil
}

func (m *OAuthResourceOwnerCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthResourceOwnerCredentials) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Audience) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Audience)))
		i += copy(dAtA[i:], m.Audience)
	}
	if len(m.GrantType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.GrantType)))
		i += copy(dAtA[i:], m.GrantType)
	}
	if len(m.ClientId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.ClientId)))
		i += copy(dAtA[i:], m.ClientId)
	}
	if len(m.Scope) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Scope)))
		i += copy(dAtA[i:], m.Scope)
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *OAuthToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if len(m.TokenType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.TokenType)))
		i += copy(dAtA[i:], m.TokenType)
	}
	if m.ExpiresIn != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.ExpiresIn))
	}
	return i, nil
}

func (m *GetAccessToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccessToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *AccessToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.AccessToken)))
		i += copy(dAtA[i:], m.AccessToken)
	}
	if m.ExpiresAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.ExpiresAt))
	}
	return i, nil
}

func (m *NtxTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	return i, nil
}

func (m *CustomNtxTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CustomNtxTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if m.Task != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Task.Size()))
		n1, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *NtxStoreToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxStoreToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NtxToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.NtxToken)))
		i += copy(dAtA[i:], m.NtxToken)
	}
	if m.ExpiresAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.ExpiresAt))
	}
	return i, nil
}

func (m *NtxTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		nn2, err := m.Response.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn2
	}
	return i, nil
}

func (m *NtxTokenResponse_Token_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Token != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Token.Size()))
		n3, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}
func (m *NtxTokenResponse_Error_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Error.Size()))
		n4, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *NtxTokenResponse_Token) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxTokenResponse_Token) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.TokenType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.TokenType)))
		i += copy(dAtA[i:], m.TokenType)
	}
	return i, nil
}

func (m *NtxTokenResponse_Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxTokenResponse_Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *AuthProviderConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthProviderConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Issuer) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Issuer)))
		i += copy(dAtA[i:], m.Issuer)
	}
	if m.Rs256 != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Rs256.Size()))
		n5, err := m.Rs256.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Hs256 != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Hs256.Size()))
		n6, err := m.Hs256.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *AuthProviderConfig_RS256) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthProviderConfig_RS256) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Input) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Input)))
		i += copy(dAtA[i:], m.Input)
	}
	return i, nil
}

func (m *AuthProviderConfig_HS256) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthProviderConfig_HS256) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Secret) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *NtxToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Iss) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Iss)))
		i += copy(dAtA[i:], m.Iss)
	}
	if m.Iat != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Iat))
	}
	if m.Nbf != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Nbf))
	}
	if m.Exp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Exp))
	}
	if len(m.Aud) > 0 {
		for _, s := range m.Aud {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Sub) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Sub)))
		i += copy(dAtA[i:], m.Sub)
	}
	if len(m.Jti) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Jti)))
		i += copy(dAtA[i:], m.Jti)
	}
	if len(m.Permissions) > 0 {
		for _, s := range m.Permissions {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.Task != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Task.Size()))
		n7, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *NtxToken_Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NtxToken_Task) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Cfg != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintToken(dAtA, i, uint64(m.Cfg.Size()))
		n8, err := m.Cfg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Label) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Label)))
		i += copy(dAtA[i:], m.Label)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	if m.Custom {
		dAtA[i] = 0x30
		i++
		if m.Custom {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintToken(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func encodeFixed64Token(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Token(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintToken(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *OAuthClientCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Audience)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.GrantType)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.ClientSecret)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *OAuthResourceOwnerCredentials) Size() (n int) {
	var l int
	_ = l
	l = len(m.Audience)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.GrantType)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Scope)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *OAuthToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.ExpiresIn != 0 {
		n += 1 + sovToken(uint64(m.ExpiresIn))
	}
	return n
}

func (m *GetAccessToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *AccessToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccessToken)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovToken(uint64(m.ExpiresAt))
	}
	return n
}

func (m *NtxTokenRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *CustomNtxTokenRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *NtxStoreToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.NtxToken)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovToken(uint64(m.ExpiresAt))
	}
	return n
}

func (m *NtxTokenResponse) Size() (n int) {
	var l int
	_ = l
	if m.Response != nil {
		n += m.Response.Size()
	}
	return n
}

func (m *NtxTokenResponse_Token_) Size() (n int) {
	var l int
	_ = l
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}
func (m *NtxTokenResponse_Error_) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}
func (m *NtxTokenResponse_Token) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.TokenType)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *NtxTokenResponse_Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *AuthProviderConfig) Size() (n int) {
	var l int
	_ = l
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.Rs256 != nil {
		l = m.Rs256.Size()
		n += 1 + l + sovToken(uint64(l))
	}
	if m.Hs256 != nil {
		l = m.Hs256.Size()
		n += 2 + l + sovToken(uint64(l))
	}
	return n
}

func (m *AuthProviderConfig_RS256) Size() (n int) {
	var l int
	_ = l
	l = len(m.Input)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *AuthProviderConfig_HS256) Size() (n int) {
	var l int
	_ = l
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *NtxToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Iss)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.Iat != 0 {
		n += 1 + sovToken(uint64(m.Iat))
	}
	if m.Nbf != 0 {
		n += 1 + sovToken(uint64(m.Nbf))
	}
	if m.Exp != 0 {
		n += 1 + sovToken(uint64(m.Exp))
	}
	if len(m.Aud) > 0 {
		for _, s := range m.Aud {
			l = len(s)
			n += 1 + l + sovToken(uint64(l))
		}
	}
	l = len(m.Sub)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Jti)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if len(m.Permissions) > 0 {
		for _, s := range m.Permissions {
			l = len(s)
			n += 1 + l + sovToken(uint64(l))
		}
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func (m *NtxToken_Task) Size() (n int) {
	var l int
	_ = l
	if m.Cfg != nil {
		l = m.Cfg.Size()
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	if m.Custom {
		n += 2
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovToken(uint64(l))
	}
	return n
}

func sovToken(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozToken(x uint64) (n int) {
	return sovToken(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OAuthClientCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthClientCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthClientCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audience", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audience = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrantType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSecret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSecret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuthResourceOwnerCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthResourceOwnerCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthResourceOwnerCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Audience", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Audience = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrantType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scope = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuthToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresIn", wireType)
			}
			m.ExpiresIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccessToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccessToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccessToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtxTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtxTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CustomNtxTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CustomNtxTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CustomNtxTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &ntx_scheduler.TaskConfiguration{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxStoreToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtxStoreToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtxStoreToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NtxToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NtxToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtxTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtxTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NtxTokenResponse_Token{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &NtxTokenResponse_Token_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NtxTokenResponse_Error{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Response = &NtxTokenResponse_Error_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxTokenResponse_Token) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Token: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Token: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxTokenResponse_Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthProviderConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthProviderConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthProviderConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rs256", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rs256 == nil {
				m.Rs256 = &AuthProviderConfig_RS256{}
			}
			if err := m.Rs256.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hs256", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hs256 == nil {
				m.Hs256 = &AuthProviderConfig_HS256{}
			}
			if err := m.Hs256.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthProviderConfig_RS256) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RS256: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RS256: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Input = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthProviderConfig_HS256) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HS256: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HS256: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NtxToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NtxToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iss", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iss = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iat", wireType)
			}
			m.Iat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iat |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nbf", wireType)
			}
			m.Nbf = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nbf |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exp", wireType)
			}
			m.Exp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aud", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aud = append(m.Aud, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sub", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sub = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &NtxToken_Task{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NtxToken_Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowToken
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cfg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cfg == nil {
				m.Cfg = &ntx_scheduler.TaskConfiguration{}
			}
			if err := m.Cfg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Custom", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Custom = bool(v != 0)
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowToken
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthToken
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipToken(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthToken
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipToken(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowToken
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowToken
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowToken
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthToken
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowToken
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipToken(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthToken = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowToken   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("ntx/auth/token.proto", fileDescriptorToken) }

var fileDescriptorToken = []byte{
	// 819 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xc1, 0x6e, 0x1c, 0x45,
	0x10, 0xcd, 0xec, 0xec, 0x38, 0xbb, 0xe5, 0x24, 0x36, 0x2d, 0x13, 0x46, 0x4b, 0xd6, 0x38, 0xc3,
	0x05, 0x09, 0x69, 0x2d, 0x19, 0x12, 0x90, 0x10, 0x07, 0xc7, 0x42, 0xd8, 0x07, 0x12, 0x34, 0xf6,
	0x89, 0x8b, 0xd5, 0x9e, 0x29, 0xdb, 0x8d, 0x77, 0x7b, 0x86, 0xee, 0x1e, 0xb2, 0xe1, 0x1b, 0xb8,
	0x22, 0xf1, 0x0d, 0xfc, 0x07, 0x12, 0x47, 0x3e, 0x21, 0x32, 0x7f, 0xc0, 0x99, 0x03, 0xaa, 0xea,
	0x9e, 0xdd, 0x89, 0x37, 0x82, 0x9c, 0x72, 0x59, 0x75, 0xbd, 0xaa, 0x57, 0xfd, 0xaa, 0xa6, 0xaa,
	0x17, 0xb6, 0xb4, 0x9b, 0xef, 0xca, 0xc6, 0x5d, 0xee, 0xba, 0xea, 0x0a, 0xf5, 0xa4, 0x36, 0x95,
	0xab, 0xc4, 0x40, 0xbb, 0xf9, 0x84, 0xd0, 0x51, 0x4a, 0x7e, 0x5b, 0x5c, 0x62, 0xd9, 0x4c, 0xd1,
	0xec, 0x3a, 0x69, 0xaf, 0x7c, 0x4c, 0xf6, 0x4b, 0x04, 0xf7, 0x9f, 0xed, 0x37, 0xee, 0xf2, 0x60,
	0xaa, 0x50, 0xbb, 0x03, 0x83, 0x25, 0x6a, 0xa7, 0xe4, 0xd4, 0x8a, 0x11, 0x0c, 0x64, 0x53, 0x2a,
	0xd4, 0x05, 0xa6, 0xd1, 0x4e, 0xf4, 0xd1, 0x30, 0x5f, 0xd8, 0x62, 0x0c, 0x70, 0x61, 0xa4, 0x76,
	0xa7, 0xee, 0x45, 0x8d, 0x69, 0x8f, 0xbd, 0x43, 0x46, 0x4e, 0x5e, 0xd4, 0x28, 0xde, 0x87, 0x61,
	0xc1, 0xf9, 0x4e, 0x55, 0x99, 0xc6, 0x9e, 0xeb, 0x81, 0xa3, 0x52, 0x7c, 0x08, 0x77, 0x83, 0xd3,
	0x62, 0x61, 0xd0, 0xa5, 0x7d, 0x0e, 0xb8, 0xe3, 0xc1, 0x63, 0xc6, 0xb2, 0xdf, 0x23, 0x18, 0xb3,
	0xae, 0x1c, 0x6d, 0xd5, 0x98, 0x02, 0x9f, 0x3d, 0xd7, 0x68, 0xde, 0x86, 0xbc, 0x2d, 0x48, 0x6c,
	0x51, 0xd5, 0x98, 0x26, 0xec, 0xf0, 0x06, 0xdd, 0xd6, 0x58, 0x34, 0x5a, 0xce, 0x30, 0x5d, 0xf3,
	0x8c, 0xd6, 0x26, 0x5f, 0x2d, 0xad, 0x7d, 0x5e, 0x99, 0x32, 0xbd, 0xed, 0x7d, 0xad, 0x9d, 0xcd,
	0x00, 0xb8, 0x8c, 0x13, 0xfa, 0x2e, 0xe2, 0x21, 0xdc, 0x91, 0x45, 0x81, 0xd6, 0x9e, 0xf2, 0x77,
	0x0a, 0xba, 0xd7, 0x3d, 0xe6, 0x43, 0xc6, 0x00, 0xec, 0x7b, 0x45, 0x3a, 0x23, 0x2c, 0x7d, 0x0c,
	0x80, 0xf3, 0x5a, 0x19, 0xb4, 0xa7, 0x4a, 0xb3, 0xf6, 0x7e, 0x3e, 0x0c, 0xc8, 0x91, 0xce, 0x0e,
	0xe1, 0xde, 0xd7, 0xe8, 0xf6, 0x3b, 0xf9, 0xba, 0xc2, 0xa3, 0xff, 0x10, 0xde, 0xbb, 0x21, 0xfc,
	0x1b, 0x58, 0xef, 0xa6, 0xd9, 0x81, 0xae, 0xca, 0xd7, 0x09, 0x7f, 0x00, 0xad, 0x8e, 0x7d, 0xc7,
	0xd9, 0x96, 0xc2, 0xf6, 0x5d, 0xf6, 0x19, 0x6c, 0x3c, 0x75, 0x73, 0x8e, 0xcc, 0xf1, 0x87, 0x06,
	0xad, 0x13, 0xf7, 0xa0, 0xa7, 0xca, 0x90, 0xa9, 0xa7, 0xb8, 0xf1, 0x53, 0x79, 0x86, 0xd3, 0x20,
	0xc5, 0x1b, 0x59, 0x01, 0xef, 0x1e, 0x34, 0xd6, 0x55, 0xb3, 0x9b, 0xf4, 0x45, 0x78, 0xd4, 0x09,
	0x17, 0x9f, 0x42, 0x9f, 0xa6, 0x9b, 0x73, 0xac, 0xef, 0xed, 0x4c, 0x68, 0x05, 0x16, 0x83, 0x3f,
	0x39, 0x91, 0xf6, 0xea, 0xa0, 0xd2, 0xe7, 0xea, 0xa2, 0x31, 0xd2, 0xa9, 0x4a, 0xe7, 0x1c, 0x9d,
	0x1d, 0xc1, 0xdd, 0xa7, 0x6e, 0x7e, 0xec, 0x2a, 0x83, 0x8b, 0xae, 0xe9, 0x70, 0x5f, 0xdb, 0xb5,
	0xd6, 0xfe, 0x9f, 0x42, 0xff, 0x8e, 0x60, 0x73, 0x29, 0xd5, 0xd6, 0x95, 0xb6, 0x28, 0x3e, 0x87,
	0x64, 0xf9, 0xc1, 0x5b, 0x59, 0xb4, 0x99, 0x93, 0x9b, 0xa1, 0x13, 0xb6, 0x0e, 0x6f, 0xe5, 0x9e,
	0x40, 0x4c, 0x34, 0xa6, 0x32, 0xaf, 0x14, 0xf4, 0x7a, 0xe6, 0x57, 0x14, 0x47, 0x4c, 0x26, 0x8c,
	0xbe, 0x80, 0xc4, 0xeb, 0xdd, 0xea, 0x5e, 0x3e, 0x6c, 0x13, 0x3f, 0x80, 0xe5, 0x54, 0xad, 0x8c,
	0xd9, 0xe8, 0x21, 0x24, 0x9c, 0x4e, 0xa4, 0x70, 0x7b, 0x86, 0xd6, 0xca, 0x8b, 0x76, 0x7a, 0x5a,
	0xf3, 0x09, 0xc0, 0xc0, 0x84, 0xab, 0xb3, 0x97, 0x11, 0x08, 0x9a, 0xf2, 0x6f, 0x4d, 0xf5, 0xa3,
	0x2a, 0xd1, 0xf8, 0x1e, 0x8b, 0xfb, 0xb0, 0xa6, 0xac, 0x6d, 0xd0, 0x04, 0x6e, 0xb0, 0xa8, 0x28,
	0x63, 0xf7, 0x1e, 0x3d, 0x4e, 0x37, 0xb8, 0xa8, 0x6c, 0x59, 0xd4, 0x6a, 0x92, 0x49, 0x7e, 0xbc,
	0xf7, 0xe8, 0x71, 0xee, 0x09, 0xc4, 0xbc, 0x64, 0xe6, 0xe6, 0x1b, 0x30, 0x0f, 0x3d, 0x93, 0x09,
	0xa3, 0x31, 0x24, 0x9c, 0x89, 0xda, 0xa1, 0x74, 0xdd, 0xb8, 0xb6, 0x1d, 0x6c, 0x8c, 0x3e, 0x80,
	0x84, 0xc3, 0x49, 0x73, 0x78, 0x96, 0x82, 0x66, 0x6f, 0x65, 0xff, 0xf4, 0x60, 0xd0, 0xb6, 0x5c,
	0x6c, 0x42, 0xac, 0xac, 0x0d, 0x11, 0x74, 0x64, 0x44, 0xfa, 0x71, 0x88, 0x73, 0x3a, 0x12, 0xa2,
	0xcf, 0xce, 0x79, 0x45, 0xe3, 0x9c, 0x8e, 0x84, 0xe0, 0xbc, 0xe6, 0xe7, 0x2e, 0xce, 0xe9, 0x48,
	0x88, 0x6c, 0xca, 0x34, 0xd9, 0x89, 0x29, 0x8f, 0x6c, 0x4a, 0x42, 0x6c, 0x73, 0x16, 0x9e, 0x18,
	0x3a, 0x12, 0xf2, 0xbd, 0x53, 0xe1, 0x61, 0xa1, 0x23, 0xed, 0x62, 0x8d, 0x66, 0xa6, 0xac, 0x55,
	0x95, 0xb6, 0xe9, 0x80, 0xd9, 0x5d, 0x88, 0x6a, 0xc4, 0x99, 0x54, 0xd3, 0x74, 0xe8, 0x6b, 0x64,
	0x43, 0x7c, 0x1c, 0x76, 0x03, 0xb8, 0x77, 0xef, 0xad, 0x8e, 0x12, 0xef, 0x87, 0x5f, 0x89, 0xd1,
	0xcf, 0x11, 0xf4, 0xc9, 0x14, 0x7b, 0x10, 0x17, 0xe7, 0x17, 0x6f, 0xbc, 0x50, 0x14, 0xbc, 0xdc,
	0xcd, 0xb8, 0xbb, 0x9b, 0x02, 0xfa, 0xa6, 0x9a, 0x62, 0x78, 0xef, 0xf9, 0x4c, 0xed, 0x2e, 0x78,
	0xbd, 0xb9, 0xe4, 0x41, 0x1e, 0xac, 0xf0, 0x38, 0x6c, 0xb4, 0x8f, 0xc3, 0x93, 0x2f, 0xff, 0xb8,
	0xde, 0x8e, 0xfe, 0xbc, 0xde, 0x8e, 0x5e, 0x5e, 0x6f, 0x47, 0xbf, 0xfe, 0xb5, 0x7d, 0x0b, 0xde,
	0x29, 0x7e, 0x62, 0x31, 0xfc, 0x3f, 0xc6, 0x75, 0x7c, 0xd7, 0xa7, 0xdf, 0xdf, 0x7a, 0xab, 0x9e,
	0xb3, 0x35, 0x3e, 0x7f, 0xf2, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xea, 0x86, 0x94, 0x9f, 0x29,
	0x07, 0x00, 0x00,
}
